/*

  Sep, 2022
  This code is ported from code acked as below.  The license stays the same.
  Porting Author: Ryan Riley <rileyrd@cmu.edu>

  ---

  06/01/2016
  Author: Makerbro
  Platforms: ESP8266
  Language: C++
  File: ACROBOTIC_SSD1306.cpp
  ------------------------------------------------------------------------
  Description:
  SSD1306 OLED Driver Library.
  ------------------------------------------------------------------------
  Please consider buying products from ACROBOTIC to help fund future
  Open-Source projects like this! We'll always put our best effort in every
  project, and release all our design files and code for you to use.
  https://acrobotic.com/
  ------------------------------------------------------------------------
  License:
  Released under the MIT license. Please check LICENSE.txt for more
  information.  All text above must be included in any redistribution.
*/

#include "i2c0.h"
#include "screen.h"

static uint8_t const char_map[] = { 0x08,  // width
        0x08,  // height

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // <space>
        0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00,  // !
        0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00,  // "
        0x00, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00,  // #
        0x00, 0x2E, 0x2A, 0x7F, 0x2A, 0x3A, 0x00, 0x00,  // $
        0x00, 0x46, 0x26, 0x10, 0x08, 0x64, 0x62, 0x00,  // %
        0x00, 0x20, 0x54, 0x4A, 0x54, 0x20, 0x50, 0x00,  // &
        0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00,  // '
        0x00, 0x00, 0x00, 0x3C, 0x42, 0x00, 0x00, 0x00,  // (
        0x00, 0x00, 0x00, 0x42, 0x3C, 0x00, 0x00, 0x00,  // )
        0x00, 0x10, 0x54, 0x38, 0x54, 0x10, 0x00, 0x00,  // *
        0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00,  // +
        0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00,  // ,
        0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00,  // -
        0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00,  // .
        0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00,  // /

        0x3C, 0x62, 0x52, 0x4A, 0x46, 0x3C, 0x00, 0x00,  // 0
        0x44, 0x42, 0x7E, 0x40, 0x40, 0x00, 0x00, 0x00,  // 1
        0x64, 0x52, 0x52, 0x52, 0x52, 0x4C, 0x00, 0x00,  // 2
        0x24, 0x42, 0x42, 0x4A, 0x4A, 0x34, 0x00, 0x00,  // 3
        0x30, 0x28, 0x24, 0x7E, 0x20, 0x20, 0x00, 0x00,  // 4
        0x2E, 0x4A, 0x4A, 0x4A, 0x4A, 0x32, 0x00, 0x00,  // 5
        0x3C, 0x4A, 0x4A, 0x4A, 0x4A, 0x30, 0x00, 0x00,  // 6
        0x02, 0x02, 0x62, 0x12, 0x0A, 0x06, 0x00, 0x00,  // 7
        0x34, 0x4A, 0x4A, 0x4A, 0x4A, 0x34, 0x00, 0x00,  // 8
        0x0C, 0x52, 0x52, 0x52, 0x52, 0x3C, 0x00, 0x00,  // 9
        0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00,  // :
        0x00, 0x00, 0x80, 0x64, 0x00, 0x00, 0x00, 0x00,  // ;
        0x00, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00,  // <
        0x00, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00,  // =
        0x00, 0x00, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,  // >
        0x00, 0x04, 0x02, 0x02, 0x52, 0x0A, 0x04, 0x00,  // ?

        0x00, 0x3C, 0x42, 0x5A, 0x56, 0x5A, 0x1C, 0x00,  // @
        0x7C, 0x12, 0x12, 0x12, 0x12, 0x7C, 0x00, 0x00,  // A
        0x7E, 0x4A, 0x4A, 0x4A, 0x4A, 0x34, 0x00, 0x00,  // B
        0x3C, 0x42, 0x42, 0x42, 0x42, 0x24, 0x00, 0x00,  // C
        0x7E, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00,  // D
        0x7E, 0x4A, 0x4A, 0x4A, 0x4A, 0x42, 0x00, 0x00,  // E
        0x7E, 0x0A, 0x0A, 0x0A, 0x0A, 0x02, 0x00, 0x00,  // F
        0x3C, 0x42, 0x42, 0x52, 0x52, 0x34, 0x00, 0x00,  // G
        0x7E, 0x08, 0x08, 0x08, 0x08, 0x7E, 0x00, 0x00,  // H
        0x00, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x00, 0x00,  // I
        0x30, 0x40, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x00,  // J
        0x7E, 0x08, 0x08, 0x14, 0x22, 0x40, 0x00, 0x00,  // K
        0x7E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00,  // L
        0x7E, 0x04, 0x08, 0x08, 0x04, 0x7E, 0x00, 0x00,  // M
        0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00,  // N
        0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00,  // O

        0x7E, 0x12, 0x12, 0x12, 0x12, 0x0C, 0x00, 0x00,  // P
        0x3C, 0x42, 0x52, 0x62, 0x42, 0x3C, 0x00, 0x00,  // Q
        0x7E, 0x12, 0x12, 0x12, 0x32, 0x4C, 0x00, 0x00,  // R
        0x24, 0x4A, 0x4A, 0x4A, 0x4A, 0x30, 0x00, 0x00,  // S
        0x02, 0x02, 0x02, 0x7E, 0x02, 0x02, 0x02, 0x00,  // T
        0x3E, 0x40, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x00,  // U
        0x1E, 0x20, 0x40, 0x40, 0x20, 0x1E, 0x00, 0x00,  // V
        0x3E, 0x40, 0x20, 0x20, 0x40, 0x3E, 0x00, 0x00,  // W
        0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00,  // X
        0x02, 0x04, 0x08, 0x70, 0x08, 0x04, 0x02, 0x00,  // Y
        0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00, 0x00,  // Z
        0x00, 0x00, 0x7E, 0x42, 0x42, 0x00, 0x00, 0x00,  // [
        0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00,  // <backslash>
        0x00, 0x00, 0x42, 0x42, 0x7E, 0x00, 0x00, 0x00,  // ]
        0x00, 0x08, 0x04, 0x7E, 0x04, 0x08, 0x00, 0x00,  // ^
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,  // _

        0x3C, 0x42, 0x99, 0xA5, 0xA5, 0x81, 0x42, 0x3C,  // `
        0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00,  // a
        0x00, 0x7E, 0x48, 0x48, 0x48, 0x30, 0x00, 0x00,  // b
        0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x00, 0x00,  // c
        0x00, 0x30, 0x48, 0x48, 0x48, 0x7E, 0x00, 0x00,  // d
        0x00, 0x38, 0x54, 0x54, 0x54, 0x48, 0x00, 0x00,  // e
        0x00, 0x00, 0x00, 0x7C, 0x0A, 0x02, 0x00, 0x00,  // f
        0x00, 0x18, 0xA4, 0xA4, 0xA4, 0xA4, 0x7C, 0x00,  // g
        0x00, 0x7E, 0x08, 0x08, 0x08, 0x70, 0x00, 0x00,  // h
        0x00, 0x00, 0x00, 0x48, 0x7A, 0x40, 0x00, 0x00,  // i
        0x00, 0x00, 0x40, 0x80, 0x80, 0x7A, 0x00, 0x00,  // j
        0x00, 0x7E, 0x18, 0x24, 0x40, 0x00, 0x00, 0x00,  // k
        0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x00, 0x00,  // l
        0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x00, 0x00,  // m
        0x00, 0x7C, 0x04, 0x04, 0x04, 0x78, 0x00, 0x00,  // n
        0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00,  // o

        0x00, 0xFC, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00,  // p
        0x00, 0x18, 0x24, 0x24, 0x24, 0xFC, 0x80, 0x00,  // q
        0x00, 0x00, 0x78, 0x04, 0x04, 0x04, 0x00, 0x00,  // r
        0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00,  // s
        0x00, 0x00, 0x04, 0x3E, 0x44, 0x40, 0x00, 0x00,  // t
        0x00, 0x3C, 0x40, 0x40, 0x40, 0x3C, 0x00, 0x00,  // u
        0x00, 0x0C, 0x30, 0x40, 0x30, 0x0C, 0x00, 0x00,  // v
        0x00, 0x3C, 0x40, 0x38, 0x40, 0x3C, 0x00, 0x00,  // w
        0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00,  // x
        0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C, 0x00, 0x00,  // y
        0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00,  // z
        0x00, 0x08, 0x08, 0x76, 0x42, 0x42, 0x00, 0x00,  // {
        0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,  // |
        0x00, 0x42, 0x42, 0x76, 0x08, 0x08, 0x00, 0x00,  // }
        0x00, 0x00, 0x04, 0x02, 0x04, 0x02, 0x00, 0x00,  // ~
        };

#define FONT_WIDTH 8

#define SSD1306_Max_X 127
#define SSD1306_Max_Y 63

#define SSD1306_Address 0x3C
#define SSD1306_Command_Mode 0x80
#define SSD1306_Data_Mode 0x40
#define SSD1306_Display_Off_Cmd 0xAE
#define SSD1306_Display_On_Cmd 0xAF
#define SSD1306_Normal_Display_Cmd 0xA6
#define SSD1306_Inverse_Display_Cmd 0xA7
#define SSD1306_Activate_Scroll_Cmd 0x2F
#define SSD1306_Dectivate_Scroll_Cmd 0x2E
#define SSD1306_Set_Brightness_Cmd 0x81

// Horizontal offset
// My screen is shifted two pixels left for some weird reason
#define H_OFFSET 0x02

void sendCommand(uint8_t command)
{
    I2C_Send2(SSD1306_Address, SSD1306_Command_Mode, command);
}

void sendData(uint8_t Data)
{
    I2C_Send2(SSD1306_Address, SSD1306_Data_Mode, Data);
}

void setTextXY(uint8_t row, uint8_t col)
{
    // There is something wrong here, but I don't know what.  Calling setTextXY(0,0) and then
    // printing a character results in that character starting offscreen on the left.

    sendCommand(0xB0 + row);                               //set page address
    sendCommand(H_OFFSET + 0x00 + (FONT_WIDTH * col & 0x0F));       //set column lower addr
    sendCommand(0x10 + ((FONT_WIDTH * col >> 4) & 0x0F)); //set column higher addr
}

void displayOn()
{
    sendCommand(0xAF);
}

void displayOff()
{
    sendCommand(0xAE);
}

void initDisplay()
{
    displayOff();       //display off
    sendCommand(0xA6);  //Set Normal Display (default)
    displayOff();       //display off
    sendCommand(0xD5);  //SETDISPLAYCLOCKDIV
    sendCommand(0x80);  // the suggested ratio 0x80
    sendCommand(0xA8);  //SSD1306_SETMULTIPLEX
    sendCommand(SSD1306_Max_Y);
    sendCommand(0xD3);        //SETDISPLAYOFFSET
    sendCommand(0x00);         //no offset
    sendCommand(0x40 | 0x0);  //SETSTARTLINE
    sendCommand(0x8D);        //CHARGEPUMP
    sendCommand(0x14);
    sendCommand(0x20);  //MEMORYMODE
    sendCommand(0x00);  //0x0 act like ks0108
    sendCommand(0xA1);  //SEGREMAP   Mirror screen horizontally (A0)
    sendCommand(0xC8);  //COMSCANDEC Rotate screen vertically (C0)
    sendCommand(0xDA);  //0xDA
    sendCommand(0x12);  //COMSCANDEC
    sendCommand(0x81);  //SETCONTRAST
    sendCommand(0xCF);  //
    sendCommand(0xd9);  //SETPRECHARGE
    sendCommand(0xF1);
    sendCommand(0xDB);  //SETVCOMDETECT
    sendCommand(0x40);
    sendCommand(0xA4);  //DISPLAYALLON_RESUME
    sendCommand(0xA6);  //NORMALDISPLAY
    clearDisplay();
    sendCommand(0x2E);  //Stop scroll
    sendCommand(0x20);  //Set Memory Addressing Mode
    sendCommand(0x00); //Set Memory Addressing Mode ab Horizontal addressing mode
}

void clearDisplay()
{
    uint8_t i, j;
    sendCommand(SSD1306_Display_Off_Cmd);  //display off
    for (j = 0; j < 8; j++)
    {
        setTextXY(j, 0);
        {
            for (i = 0; i < 16; i++)  //clear all columns.  17 here because if I use 16, then there is junk left on the far right side.
            {
                putChar(' ');
            }
        }
    }
    sendCommand(SSD1306_Display_On_Cmd);  //display on
    setTextXY(0, 0);
}

void clearLine(uint8_t row)
{
    uint8_t i;

    setTextXY(row, 0);
    for(i = 0; i < 16; i++) {
        putChar(' ');
    }
}

void putChar(uint8_t ch)
{
    uint8_t i;

    if (ch < 32 || ch > 127)
    {
        ch = ' ';
    }
    for (i = 0; i < FONT_WIDTH; i++)
    {
        // Font array starts at 0, ASCII starts at 32
        sendData(char_map[(ch - 32) * FONT_WIDTH + 2 + i]);
    }
}

void putString(const char *string)
{
    uint8_t i = 0;
    while (string[i])
    {
        putChar(string[i]);
        i++;
    }
}

uint8_t putNumber(long long_num)
{
  uint8_t char_buffer[10]="";
  uint8_t i = 0;
  uint8_t f = 0;

  if (long_num < 0)
  {
    f=1;
    putChar('-');
    long_num = -long_num;
  }
  else if (long_num == 0)
  {
    f=1;
    putChar('0');
    return f;
  }

  while (long_num > 0)
  {
    char_buffer[i++] = long_num % 10;
    long_num /= 10;
  }

  f=f+i;
  for(; i > 0; i--)
  {
    putChar('0'+ char_buffer[i - 1]);
  }
  return f;

}
